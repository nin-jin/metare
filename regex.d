module regex;
const int testFail = -1;

/**
 * Compile pattern[] and expand to a custom generated
 * function that will take a string str[] and apply the
 * regular expression to it, returning an array of matches.
 */

template regexMatch(string pattern)
{
    string[] regexMatch(string str)
    {
        string[] results;
        int n = regexCompile!(pattern).fn(str);
        if (n != testFail && n > 0)
            results ~= str[0..n];
        return results;
    }
}

/******************************
 * The testXxxx() functions are custom generated by templates
 * to match each predicate of the regular expression.
 *
 * Params:
 *	string str	the input string to match against
 *
 * Returns:
 *	testFail	failed to have a match
 *	n >= 0		matched n characters
 */

/// Always match
template testEmpty()
{
    int testEmpty(string str) { return 0; }
}

/// Match if testFirst(str) and testSecond(str) match
template testUnion(alias testFirst, alias testSecond)
{
    int testUnion(string str)
    {
        int n1 = testFirst(str);
        if (n1 != testFail)
        {
            int n2 = testSecond(str[n1 .. $]);
            if (n2 != testFail)
                return n1 + n2;
        }
        return testFail;
    }
}

/// Match if first part of str[] matches text[]
template testText(string text)
{
    int testText(string str)
    {
        if (str.length &&
            text.length <= str.length &&
            str[0..text.length] == text)
        {
            return text.length;
        }
        return testFail;
    }
}

/// Match if testPredicate(str) matches 0 or more times
template testZeroOrMore(alias testPredicate)
{
    int testZeroOrMore(string str)
    {
        if (str.length == 0)
            return 0;
        int n = testPredicate(str);
        if (n != testFail)
        {
            int n2 = testZeroOrMore!(testPredicate)(str[n .. $]);
            if (n2 != testFail)
                return n + n2;
            return n;
        }
        return 0;
    }
}

/// Match if term1[0] <= str[0] <= term2[0]
template testRange(string term1, string term2)
{
    int testRange(string str)
    {
        if (str.length && str[0] >= term1[0]
                       && str[0] <= term2[0])
            return 1;
        return testFail;
    }
}

/// Match if ch[0]==str[0]
template testChar(string ch)
{
    int testChar(string str)
    {
        if (str.length && str[0] == ch[0])
            return 1;
        return testFail;
    }
}

/// Match if str[0] is a word character
template testWordChar()
{
    int testWordChar(string str)
    {
        if (str.length &&
            (
             (str[0] >= 'a' && str[0] <= 'z') ||
             (str[0] >= 'A' && str[0] <= 'Z') ||
             (str[0] >= '0' && str[0] <= '9') ||
             str[0] == '_'
            )
           )
        {
            return 1;
        }
        return testFail;
    }
}

/*****************************************************/

/**
 * Returns the front of pattern[] up until
 * the end or a special character.
 */

template parseTextToken(string pattern)
{
    static if (pattern.length > 0)
    {
        static if (isSpecial!(pattern))
            const string parseTextToken = "";
        else
            const string parseTextToken =
                pattern[0..1] ~ parseTextToken!(pattern[1..$]);
    }
    else
        const string parseTextToken="";
}

/**
 * Parses pattern[] up to and including terminator.
 * Returns:
 *	token[]	 	everything up to terminator.
 *	consumed	number of characters in pattern[] parsed
 */
template parseUntil(string pattern,char terminator,bool fuzzy=false)
{
    static if (pattern.length > 0)
    {
        static if (pattern[0] == '\\')
        {
            static if (pattern.length > 1)
            {
                const string nextSlice = pattern[2 .. $];
                alias next = parseUntil!(nextSlice,terminator,fuzzy);
                const string token = pattern[0 .. 2] ~ next.token;
                const uint consumed = next.consumed+2;
            }
            else
            {
                pragma(msg,"Error: expected character to follow \\");
                static assert(false);
            }
        }
        else static if (pattern[0] == terminator)
        {
            const string token="";
            const uint consumed = 1;
        }
        else
        {
            const string nextSlice = pattern[1 .. $];
            alias next = parseUntil!(nextSlice,terminator,fuzzy);
            const string token = pattern[0..1] ~ next.token;
            const uint consumed = next.consumed+1;
        }
    }
    else static if (fuzzy)
    {
        const string token = "";
        const uint consumed = 0;
    }
    else
    {
        pragma(msg, "Error: expected " ~
                    terminator ~
                    " to terminate group expression");
        static assert(false);
    }
}

/**
 * Parse contents of character class.
 * Params:
 *   pattern[] = rest of pattern to compile
 * Output:
 *   fn       = generated function
 *   consumed = number of characters in pattern[] parsed
 */

template regexCompileCharClass2(string pattern)
{
    static if (pattern.length > 0)
    {
        static if (pattern.length > 1)
        {
            static if (pattern[1] == '-')
            {
                static if (pattern.length > 2)
                {
                    alias termFn = testRange!(pattern[0..1], pattern[2..3]);
                    const uint thisConsumed = 3;
                    const string remaining = pattern[3 .. $];
                }
                else // length is 2
                {
                    pragma(msg,
                      "Error: expected char following '-' in char class");
                    static assert(false);
                }
            }
            else // not '-'
            {
                alias termFn = testChar!(pattern[0..1]);
                const uint thisConsumed = 1;
                const string remaining = pattern[1 .. $];
            }
        }
        else
        {
            alias termFn = testChar!(pattern[0..1]);
            const uint thisConsumed = 1;
            const string remaining = pattern[1 .. $];
        }
        alias recurse = regexCompileCharClassRecurse!(termFn,remaining);
        alias fn = recurse.fn;
        const uint consumed = recurse.consumed + thisConsumed;
    }
    else
    {
        alias fn = testEmpty!();
        const uint consumed = 0;
    }
}

/**
 * Used to recursively parse character class.
 * Params:
 *  termFn = generated function up to this point
 *  pattern[] = rest of pattern to compile
 * Output:
 *  fn = generated function including termFn and
 *       parsed character class
 *  consumed = number of characters in pattern[] parsed
 */

template regexCompileCharClassRecurse(alias termFn,string pattern)
{
    static if (pattern.length > 0 && pattern[0] != ']')
    {
        alias next = regexCompileCharClass2!(pattern);
        alias fn = testOr!(termFn,next.fn,pattern);
        const uint consumed = next.consumed;
    }
    else
    {
        alias fn = termFn;
        const uint consumed = 0;
    }
}

/**
 * At start of character class. Compile it.
 * Params:
 *  pattern[] = rest of pattern to compile
 * Output:
 *  fn = generated function
 *  consumed = number of characters in pattern[] parsed
 */

template regexCompileCharClass(string pattern)
{
    static if (pattern.length > 0)
    {
        static if (pattern[0] == ']')
        {
            alias fn = testEmpty!();
            const uint consumed = 0;
        }
        else
        {
            alias charClass = regexCompileCharClass2!(pattern);
            alias fn = charClass.fn;
            const uint consumed = charClass.consumed;
        }
    }
    else
    {
        pragma(msg,"Error: expected closing ']' for character class");
        static assert(false);
    }
}

/**
 * Look for and parse '*' postfix.
 * Params:
 *  test = function compiling regex up to this point
 *  pattern[] = rest of pattern to compile
 * Output:
 *  fn = generated function
 *  consumed = number of characters in pattern[] parsed
 */

template regexCompilePredicate(alias test, string pattern)
{
    static if (pattern.length > 0 && pattern[0] == '*')
    {
        alias fn = testZeroOrMore!(test);
        const uint consumed = 1;
    }
    else
    {
        alias fn = test;
        const uint consumed = 0;
    }
}

/**
 * Parse escape sequence.
 * Params:
 *  pattern[] = rest of pattern to compile
 * Output:
 *  fn = generated function
 *  consumed = number of characters in pattern[] parsed
 */

template regexCompileEscape(string pattern)
{
    static if (pattern.length > 0)
    {
        static if (pattern[0] == 's')
        {
            // whitespace char
            alias fn = testRange!("\x00","\x20");
        }
        else static if (pattern[0] == 'w')
        {
            // word char
            alias fn = testWordChar!();
        }
        else
        {
            alias fn = testChar!(pattern[0 .. 1]);
        }
        const uint consumed = 1;
    }
    else
    {
        pragma(msg,"Error: expected char following '\\'");
        static assert(false);
    }
}

/**
 * Parse and compile regex represented by pattern[].
 * Params:
 *  pattern[] = rest of pattern to compile
 * Output:
 *  fn = generated function
 */

template regexCompile(string pattern)
{
    static if (pattern.length > 0)
    {
        static if (pattern[0] == '[')
        {
            const string charClassToken =
                parseUntil!(pattern[1 .. $],']').token;
            alias charClass = regexCompileCharClass!(charClassToken);
            const string token = pattern[0 .. charClass.consumed+2];
            const string next = pattern[charClass.consumed+2 .. $];
            alias test = charClass.fn;
        }
        else static if (pattern[0] == '\\')
        {
            alias escapeSequence =
                regexCompileEscape!(pattern[1 .. pattern.length]);
            const string token = pattern[0 .. escapeSequence.consumed+1];
            const string next =
                pattern[escapeSequence.consumed+1 .. $];
            alias test = escapeSequence.fn;
        }
        else
        {
            const string token = parseTextToken!(pattern);
            static assert(token.length > 0);
            const string next = pattern[token.length .. $];
            alias test = testText!(token);
        }

        alias term = regexCompilePredicate!(test, next);
        const string remaining = next[term.consumed .. next.length];

        alias fn = regexCompileRecurse!(term,remaining).fn;
    }
    else
        alias fn = testEmpty!();
}

template regexCompileRecurse(alias term,string pattern)
{
    static if (pattern.length > 0)
    {
        alias next = regexCompile!(pattern);
        alias fn = testUnion!(term.fn, next.fn);
    }
    else
        alias fn = term.fn;
}

/// Utility function for parsing
template isSpecial(string pattern)
{
    static if (
        pattern[0] == '*' ||
        pattern[0] == '+' ||
        pattern[0] == '?' ||
        pattern[0] == '.' ||
        pattern[0] == '[' ||
        pattern[0] == '{' ||
        pattern[0] == '(' ||
        pattern[0] == ')' ||
        pattern[0] == '$' ||
        pattern[0] == '^' ||
        pattern[0] == '\\'
    )
        const isSpecial = true;
    else
        const isSpecial = false;
}
